# tmiDB — Too-Much-Information DataBase

**MIT / Apache-2 / BSD 퍼미시브 라이선스 전용 설계서 (v0.1)**

---

## 1. 구성 요소 & 라이선스

| 계층 | 컴포넌트 | 라이선스 | 비고 |⸻

⸻

| **DB 엔진** | PostgreSQL 15 | PostgreSQL (BSD) | 기반 RDB |
| **시계열** | TimescaleDB 2.18 **코어** | Apache-2.0 | `compress_chunks` 까지만 사용 |
| **공간 / 거리** | `cube` + `earthdistance` | BSD | 반경·근접 질의 |
| **객체 스토리지** | SeaweedFS S3 Gateway | Apache-2.0 | MinIO 대체 |
| **메시지 버스** | NATS JetStream | Apache-2.0 | ETL·알람 |

> **GPL/AGPL 전혀 없음** — 상용/SaaS 재배포 100 % 안전.

---

## 2. 핵심 개념

tmiDB는 특정 **대상(Target)**에 대한 모든 정보를 중앙에서 관리하고, 실시간으로 스트리밍하기 위해 설계된 데이터베이스입니다.

- **대상 (Target)**: 정보를 수집하고 관리할 기본 단위입니다. 사람, 장비, 서비스 등 모든 것이 대상이 될 수 있습니다.
- **스피커 (Speaker)**: 대상에 대한 정보를 생성하고 데이터베이스에 쓰는 주체입니다. API 호출, 직접적인 DB 쿼리, 또는 tmiDB가 특정 URL에서 데이터를 주기적으로 스크랩하는 자동화된 에이전트 등 다양한 형태가 될 수 있습니다.
- **리스너 (Listener)**: 특정 대상의 정보를 구독하는 주체입니다. 대상에 대한 읽기 권한을 부여받으면, 자동 생성된 REST API 엔드포인트에 접근할 수 있으며, WebSocket을 통해 정보 업데이트를 실시간으로 스트리밍 받을 수 있습니다.

### 주요 특징

- **동적 스키마**: MongoDB처럼 대상에 대한 정보 항목(컬럼)을 미리 정의할 필요 없이 자유롭게 추가할 수 있습니다. 정보 스키마가 변경될 때마다 내부적으로 버전이 관리됩니다.
- **자동화된 API 생성 및 버전 관리**: 대상의 데이터 구조가 변경되면, 그에 맞춰 REST API가 자동으로 업데이트되고 버전이 부여됩니다. 이는 gRPC와 유사한 방식으로 API 호환성을 보장합니다.
- **유연한 데이터 수집**: Speaker는 DB 쿼리, REST API 등 다양한 방식으로 데이터를 입력할 수 있습니다. 또한, 특정 웹 페이지의 URL을 등록하면 tmiDB 내부의 코드가 주기적으로 해당 페이지의 정보를 수집하여 저장하는 기능도 제공합니다.

## 2.1. 보안 및 인증

tmiDB는 내부 시스템과 외부 API 사용자를 위한 명확한 보안 및 인증 체계를 가집니다.

### 인증 방식

API 및 서비스 접근은 두 가지 방식으로 인증됩니다.

1.  **ID / Password**: 사용자 계정의 아이디와 비밀번호를 이용한 기본 인증입니다.
2.  **API 토큰 (`database-token`)**: 사용자가 발급받은 Bearer 토큰을 이용한 인증입니다. 자동화된 스크립트나 외부 서비스 연동에 권장됩니다.

### 토큰 관리 정책

- **발급**: 사용자는 여러 개의 API 토큰을 생성하여 용도에 따라 관리할 수 있습니다. 토큰은 계정이 생성될 때 기본적으로 하나가 발급될 수 있으며, 추가 발급도 가능합니다.
- **권한**:
  - **관리자 (Admin)**: 시스템에 등록된 모든 사용자의 토큰 목록을 조회하고, 특정 토큰을 강제로 삭제할 수 있는 권한을 가집니다.
  - **일반 사용자 (Viewer 등)**: 자신이 발급받은 토큰만 조회하고 관리할 수 있습니다.

⸻

## 4. 아키텍처 (v0.3 - 최종)

**핵심 설계 원칙: 독립적인 프로젝트 모듈 (Independent Project Modules)**

tmiDB는 하나의 거대한 모노레포가 아닌, 기능 단위로 명확하게 분리된 여러 개의 독립적인 프로젝트로 구성됩니다. 각 프로젝트는 자체적인 소스 코드, 의존성, 빌드 및 배포 설정을 가집니다. 이를 통해 각 기능 모듈(제품)을 독립적으로 개발, 테스트, 배포할 수 있습니다.

### 4.1. 프로젝트 구조

- **tmidb-core/**: 데이터베이스, 웹 콘솔, 핵심 API 등 tmiDB의 기본 기능을 제공하는 코어 프로젝트입니다. `poi0322/tmidb-core:0.1` 이미지를 빌드합니다.
- **tmidb-mqtt/**: MQTT 프로토콜을 통한 데이터 수집 및 publish를 담당하는 확장 모듈 프로젝트입니다. `poi0322/tmidb-mqtt:0.1` 이미지를 빌드합니다.
- **tmidb-realtime/**: WebSocket을 통한 실시간 데이터 수집 및 스트리밍을 담당하는 확장 모듈 프로젝트입니다. `poi0322/tmidb-realtime:0.1` 이미지를 빌드합니다.

### TODO

- **tmidb-poller/**: 데이터 수집기 프로젝트입니다. `poi0322/tmidb-poller:0.1` 이미지를 빌드합니다.

### 4.2. 실행 및 오케스트레이션

실행 순서는 `README.md`에 명시된 대로, `tmidb-core` 뒤, 필요한 확장 모듈들을 순차적으로 실행합니다.

### 4.3. 쓰기 경로 이원화 (Write Path Strategy)

- **동기 쓰기 (Synchronous Write)**: 사용자 생성, 설정 변경 등 즉각적인 피드백이 필요하고 트랜잭션이 중요한 요청입니다. API 게이트웨이가 직접 DB 커넥션을 사용하여 처리합니다.
- **비동기 쓰기 (Asynchronous Write)**: IoT 센서 데이터, 로그 등 대량으로 수집되는 데이터입니다. 데이터 수집기(mqtt)는 받은 데이터를 NATS에 발행하기만 합니다. 실제 DB에 쓰는 작업은 Worker가 NATS 큐를 통해 순차적이고 안정적으로 처리하여 DB 부하를 최소화합니다.

⸻

## 6. 초기 로드맵

주 목표
1 레포·Compose 기동 / DB 초기 스키마
2 pollingd → raw_bucket INSERT
3 normsvc AI 매핑 → 정규 테이블
4 Realtime WS / stream_def 적용
5 alarm_engine 임계값 알람
6 콘솔 MVP·tmictl CLI 배포

⸻

7. 라이선스 파일

LICENSE → MIT
Each Go/TS file → SPDX-License-Identifier: MIT

tmiDB 전체 스택은 MIT/Apache/BSD 만을 사용하여,
코드 포크·상용 판매·SaaS 배포 모두 제한 없이 가능하다.

---


⸻

## 8. 초기 로드맵

| 주  | 목표                               |
| --- | ---------------------------------- |
| 1   | 레포·Compose 기동 / DB 초기 스키마 |
| 2   | INSERT                             |
| 3   | 정규 테이블                        |
| 4   | Realtime WS                        |
| 5   |                                    |
| 6   | 콘솔 MVP·tmictl CLI 배포           |

⸻

## 11. 고급 아키텍처 패턴

tmiDB의 기본 구성 요소 위에 더 정교한 기능을 구현하기 위한 아키텍처 패턴입니다.

### 리스너별 동적 API 및 실시간 필터링

**문제:** 모든 리스너가 동일한 API 엔드포인트를 사용하는 것이 아니라, `api/리스너A`처럼 자신만의 엔드포인트를 갖고 구독한 데이터만 필터링해서 받고 싶다.

**해결책:** tmiDB 스택 앞에 **API 게이트웨이** 또는 **인증/프록시 서비스**를 배치합니다.

**동작 흐름:**

1.  **구독 정보 관리**: 리스너의 구독 정보(대상 ID, 필터링할 필드 등)를 `listener_subscriptions`와 같은 별도의 메타데이터 테이블에 저장합니다.
2.  **API 요청 처리 (Gateway)**:
    - 클라이언트가 `GET /api/listener_a`로 요청을 보냅니다.
    - API 게이트웨이는 `listener_a`의 구독 정보를 DB에서 조회합니다.
    - 게이트웨이는 조회된 정보를 바탕으로 실제 PostgREST에 보낼 쿼리(예: `GET /target?id=eq.X&select=meta->>field1,meta->>field2`)를 동적으로 생성하여 요청합니다.
    - PostgREST의 응답을 받아 클라이언트에게 최종 전달합니다.
3.  **실시간 메시지 필터링 (WebSocket Proxy)**:
    - 클라이언트가 `ws/listener_a`로 연결합니다.
    - 프록시 서비스는 해당 리스너가 구독 중인 대상의 Realtime 채널에 대신 연결합니다.
    - Realtime에서 오는 모든 변경사항 중, 리스너가 구독하기로 한 필드에 해당하는 내용만 선별하여 클라이언트에게 전달합니다.

### 대용량 파일 처리 (이벤트 알림 방식)

**문제:** 이미지, 동영상 등 대용량 파일을 WebSocket으로 직접 전송하는 것은 비효율적이다.

**해결책:** 파일은 S3 호환 스토리지(SeaweedFS)를 통해 전달하고, WebSocket으로는 파일이 변경되었다는 **이벤트 알림**만 전달합니다.

**동작 흐름:**

1.  **파일 업로드**: 스피커가 파일을 SeaweedFS(S3)에 업로드합니다.
2.  **메타데이터 저장**: 업로드가 완료되면, 파일의 위치, 이름, 크기 등의 메타데이터를 `ts_obs`나 별도의 `file_attachments` 테이블에 JSON 형태로 저장합니다.
3.  **이벤트 알림**:
    - 테이블에 새로운 레코드가 INSERT되면, Supabase Realtime이 이 변경 이벤트를 감지합니다.
    - Realtime은 파일 자체가 아닌, 파일이 업로드되었다는 사실과 그 메타데이터(JSON)를 리스너에게 실시간으로 전송합니다.
4.  **파일 다운로드**:
    - 리스너의 클라이언트는 WebSocket으로 이벤트 알림을 받습니다.
    - 클라이언트는 알림에 포함된 파일 경로(메타데이터)를 이용해 SeaweedFS(S3)에 직접 HTTP 요청을 보내 파일을 다운로드합니다.

이 패턴들을 통해 tmiDB의 핵심은 단순하게 유지하면서, 필요에 따라 확장성 있는 고급 기능을 구현할 수 있습니다.
